package com.momentor.mentors.Service;
import com.momentor.mentors.DTO.AiTask;
import com.momentor.mentors.DTO.TaskResponseDto;
import com.momentor.mentors.Exception.ResourceNotFoundException;
import com.momentor.mentors.entity.Meeting;
import com.momentor.mentors.entity.Moms;
import com.momentor.mentors.entity.Task;
import com.momentor.mentors.repository.MeetingRepository;
import com.momentor.mentors.repository.MomRepository;
import com.momentor.mentors.repository.TaskRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
// Spring HTTP
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
// Spring Security
import org.springframework.security.core.Authentication;
// Your DTOs
import com.momentor.mentors.DTO.MeetingWithMomResponseDto;
// Your Exceptions
import com.momentor.mentors.DTO.ErrorResponse;
// Java collections
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.stream.Collectors;
@Service
public class TaskService {
    @Autowired
    private TaskRepository taskRepository;
    @Autowired
    private MomRepository momRepository;
    @Autowired
    private MeetingRepository meetingRepository;
    @Autowired
    private userservice userservice;
    @Autowired
    private MomService momservice;
    //create Task From MOM
    public Task createtask(String title, String assignedTo, Long momid){
        //Fetch Moms Entity From DB
        Moms mom=momRepository.findById(momid).orElseThrow(()->new ResourceNotFoundException("Mom Not Found"));
        //Create A Task
        Task task=new Task();
        task.setTitle(title);
        task.setAssignedTo(assignedTo);
        //Set Moms Entity
        task.setMom(mom);
        task.setAutoGenerated(false); //manual work ai suggest be block
        task.setApproved(true); //always  approved a manual task
        return taskRepository.save(task);
    }
    //update Task Status
    public Task updatestatus(Long taskid,String status){
        Task task=taskRepository.findById(taskid).orElseThrow(()->new ResourceNotFoundException("Task Not Found"));
        task.setStatus(status);
        return taskRepository.save(task);
    }
    //Get All Tasks
    public List<Task> getalltasks(){
        return taskRepository.findAll();
    }
    //Get The Tasks By Specific User
    public List<TaskResponseDto> gettaskbyuserdto(String email){

        String studentName = userservice.getUserNameByEmail(email);

        return taskRepository.findAll().stream()
                .filter(Task::isApproved)
                .filter(task ->
                        task.getAssignedTo().equalsIgnoreCase(email) ||
                                (studentName != null &&
                                        task.getAssignedTo().equalsIgnoreCase(studentName))
                )
                .map(task -> new TaskResponseDto(
                        task.getId(),
                        task.getTitle(),
                        task.getAssignedTo(),
                        task.getStatus(),
                        task.isAutoGenerated(),
                        task.isApproved(),
                        task.getResources()
                ))
                .collect(Collectors.toList());
    }
    //Get All The Tasks Based On Task ResponseDto
    public List<TaskResponseDto> getalltaskdto(){
        return taskRepository.findAll()
                .stream()
                .map(task -> new TaskResponseDto(task.getId(),task.getTitle(),task.getAssignedTo(),task.getStatus(),task.isAutoGenerated(),task.isApproved(),task.getResources()))
                .collect(Collectors.toList());
    }
    //Add Pagination
    public Page<TaskResponseDto> gettaskwithpagination(int page,int size,String sortby,String direction){
        Sort sort=direction.equalsIgnoreCase("desc")
                ?Sort.by(sortby).descending()
                :Sort.by(sortby).ascending();
        Pageable pageable= PageRequest.of(page,size,sort);
        return taskRepository.findAll(pageable).map(task -> new TaskResponseDto(task.getId(),task.getTitle(),task.getAssignedTo(),task.getStatus(),task.isAutoGenerated(),task.isApproved(),task.getResources()));
    }
    public double calculatemeetingprogress(Long meetingid){
        Moms mom=momRepository.findById(meetingid).orElseThrow(()->new ResourceNotFoundException("Meeting Id Not Found"));
        List<Task> tasks=taskRepository.findByMomId(mom.getId());
        if(tasks.isEmpty()){
            return 0.0;
        }
        long completed=tasks.stream()
                .filter(task -> "DONE".equals(task.getStatus()))
                .count();
        return (completed*100.0)/tasks.size();
    }
    public Task getTaskById(Long taskId) {
        return taskRepository.findById(taskId)
                .orElseThrow(() ->
                        new ResourceNotFoundException("Task not found"));
    }
    // Add these methods to your existing TaskService class
    // Check if a student is assigned a task in a specific meeting
    public boolean isStudentAssignedToMeeting(Long meetingId, String studentEmail) {
        Moms mom = momRepository.findByMeeting_Id(meetingId).orElse(null);
        if (mom == null) {
            return false;
        }

        List<Task> tasks = taskRepository.findByMomId(mom.getId());
        return tasks.stream()
                .anyMatch(task -> studentEmail.equals(task.getAssignedTo()));
    }
    // In com.momentor.mentors.Service.TaskService
    public List<TaskResponseDto> gettaskbymentor(Long mentorId) {
        // Get all meetings for this mentor
        List<Meeting> meetings = meetingRepository.findByMentorid(mentorId);

        // Get all MOMs from these meetings
        List<Long> momIds = meetings.stream()
                .flatMap(m -> momRepository.findByMeeting_Id(m.getId()).stream())
                .map(Moms::getId)
                .collect(Collectors.toList());

        if (momIds.isEmpty()) {
            return new ArrayList<>();
        }

        // Get all tasks from these MOMs
        return taskRepository.findByMomIdIn(momIds).stream()
                .map(task -> new TaskResponseDto(
                        task.getId(),
                        task.getTitle(),
                        task.getAssignedTo(),
                        task.getStatus(),task.isAutoGenerated(),task.isApproved(),task.getResources()
                ))
                .collect(Collectors.toList());
    }
    public ResponseEntity<?> getMeetingByTaskService(
            Long taskId,
            Authentication authentication
    ) {
        try {
            Task task = getTaskById(taskId);
            if (task == null) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body(new ErrorResponse("Task not found"));
            }

            String email = authentication.getName();
            String role = authentication.getAuthorities().stream()
                    .map(Object::toString)
                    .filter(auth ->
                            auth.contains("ROLE_MENTOR") ||
                                    auth.contains("ROLE_STUDENT") ||
                                    auth.contains("ROLE_ADMIN"))
                    .findFirst()
                    .orElse("");

            // STUDENT can only view their own assigned tasks
            if (role.contains("STUDENT")) {
                String studentName = userservice.getUserNameByEmail(email);
                boolean isAssigned =
                        task.getAssignedTo().equalsIgnoreCase(email) ||
                                (studentName != null &&
                                        task.getAssignedTo().equalsIgnoreCase(studentName));

                if (!isAssigned) {
                    return ResponseEntity.status(HttpStatus.FORBIDDEN)
                            .body(new ErrorResponse("You are not assigned to this task"));
                }
            }

            // MENTOR / ADMIN access
            if (role.contains("MENTOR") || role.contains("ADMIN")) {
                Long userId = userservice.getUserIdByEmail(email);
                Meeting meeting = task.getMom().getMeeting();

                if (!role.contains("ADMIN") &&
                        !meeting.getMentorid().equals(userId)) {

                    return ResponseEntity.status(HttpStatus.FORBIDDEN)
                            .body(new ErrorResponse("You can only view tasks from your own meetings"));
                }
            }
            Meeting meeting = task.getMom().getMeeting();
            Moms mom = momservice.getMomByMeetingOrNull(meeting);
            MeetingWithMomResponseDto dto =
                    new MeetingWithMomResponseDto(
                            meeting.getId(),
                            meeting.getTitle(),
                            meeting.getMeetingdate(),
                            mom != null ? mom.getId() : null,
                            mom != null ? mom.getMomtext() : null
                    );
            return ResponseEntity.ok(dto);
        } catch (ResourceNotFoundException rnfe) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(new ErrorResponse(rnfe.getMessage()));
        } catch (Exception ex) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Error fetching meeting: " + ex.getMessage()));
        }
    }
    //Dashboard For Student
    public ResponseEntity<?> getMentorDashboardSummaryService(Authentication authentication) {
        try {
            String email = authentication.getName();
            Long mentorId = userservice.getUserIdByEmail(email);
            List<TaskResponseDto> tasks = gettaskbymentor(mentorId);
            long totalTasks = tasks.size();
            long doneTasks = tasks.stream()
                    .filter(t -> "DONE".equalsIgnoreCase(t.getStatus()))
                    .count();
            long inProgressTasks = tasks.stream()
                    .filter(t -> "IN_PROGRESS".equalsIgnoreCase(t.getStatus()))
                    .count();
            long notStartedTasks = tasks.stream()
                    .filter(t -> "NOT_STARTED".equalsIgnoreCase(t.getStatus()))
                    .count();
            double overallProgress =
                    totalTasks > 0 ? (doneTasks * 100.0) / totalTasks : 0;
            Map<String, Object> response = new HashMap<>();
            response.put("totalTasks", totalTasks);
            response.put("doneTasks", doneTasks);
            response.put("inProgressTasks", inProgressTasks);
            response.put("notStartedTasks", notStartedTasks);
            response.put("overallprogress", overallProgress);
            return ResponseEntity.ok(response);

        } catch (Exception ex) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Failed to load dashboard summary: " + ex.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
        }
    }
    //Dashboard For Mentor
    public ResponseEntity<?> getStudentDashboardSummaryService(Authentication authentication) {
        try {
            String email = authentication.getName();
            List<TaskResponseDto> tasks = gettaskbyuserdto(email);
            long totalTasks = tasks.size();
            long doneTasks = tasks.stream()
                    .filter(t -> "DONE".equalsIgnoreCase(t.getStatus()))
                    .count();
            long inProgressTasks = tasks.stream()
                    .filter(t -> "IN_PROGRESS".equalsIgnoreCase(t.getStatus()))
                    .count();
            long notStartedTasks = tasks.stream()
                    .filter(t -> "NOT_STARTED".equalsIgnoreCase(t.getStatus()))
                    .count();
            double overallProgress =
                    totalTasks > 0 ? (doneTasks * 100.0) / totalTasks : 0;
            Map<String, Object> response = new HashMap<>();
            response.put("totalTasks", totalTasks);
            response.put("doneTasks", doneTasks);
            response.put("inProgressTasks", inProgressTasks);
            response.put("notStartedTasks", notStartedTasks);
            response.put("overallprogress", overallProgress);
            return ResponseEntity.ok(response);

        } catch (Exception ex) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Failed to load dashboard summary: " + ex.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
        }
    }
    //Dashboard for Admin
    public ResponseEntity<?> getAdminDashboardSummaryService() {
        try {
            List<TaskResponseDto> tasks = getalltaskdto();

            long totalTasks = tasks.size();
            long doneTasks = tasks.stream()
                    .filter(t -> "DONE".equalsIgnoreCase(t.getStatus()))
                    .count();
            long inProgressTasks = tasks.stream()
                    .filter(t -> "IN_PROGRESS".equalsIgnoreCase(t.getStatus()))
                    .count();
            long notStartedTasks = tasks.stream()
                    .filter(t -> "NOT_STARTED".equalsIgnoreCase(t.getStatus()))
                    .count();

            double overallProgress =
                    totalTasks > 0 ? (doneTasks * 100.0) / totalTasks : 0;

            Map<String, Object> response = new HashMap<>();
            response.put("totalTasks", totalTasks);
            response.put("doneTasks", doneTasks);
            response.put("inProgressTasks", inProgressTasks);
            response.put("notStartedTasks", notStartedTasks);
            response.put("overallprogress", overallProgress);

            return ResponseEntity.ok(response);

        } catch (Exception ex) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Failed to load dashboard summary: " + ex.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
        }
    }
    public void saveAiTasks(List<AiTask> tasks, Moms mom) {
        for (AiTask aiTask : tasks) { //Set of   the Task Where In Ai Draft
            Task task = new Task(); //Get The Task Entity Object
            task.setTitle(aiTask.getTitle());
            task.setAssignedTo(aiTask.getAssignedTo());
            task.setResources(aiTask.getResources());
            task.setAutoGenerated(true);
            task.setApproved(false);
            task.setStatus("NOT_STARTED");
            task.setMom(mom);
            taskRepository.save(task);
        }
    }
    //AI Task Deletion
    public void deleteTask(Long taskId) {
        taskRepository.deleteById(taskId);
    }
}