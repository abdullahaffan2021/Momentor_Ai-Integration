package com.momentor.mentors.Service;
import com.momentor.mentors.DTO.*;
import com.momentor.mentors.Exception.ResourceNotFoundException;
import com.momentor.mentors.entity.Meeting;
import com.momentor.mentors.entity.Moms;
import com.momentor.mentors.entity.Task;
import com.momentor.mentors.entity.Team;
import com.momentor.mentors.repository.MeetingRepository;
import com.momentor.mentors.repository.MomRepository;
import com.momentor.mentors.repository.TaskRepository;
import com.momentor.mentors.repository.TeamRepository;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
// Spring HTTP
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
// Spring Security
import org.springframework.security.core.Authentication;
// Your DTOs
// Your Exceptions
// Java collections
import java.util.*;
import java.util.stream.Collectors;
@Service
public class TaskService {
    @Autowired
    private TaskRepository taskRepository;
    @Autowired
    private MomRepository momRepository;
    @Autowired
    private MeetingRepository meetingRepository;
    @Autowired
    private TeamRepository teamRepository;
    @Autowired
    private userservice userservice;
    @Autowired
    private MomService momservice;
    //create Task From MOM
    public Task createtask(String title, String assignedTo, Long momid){
        //Fetch Moms Entity From DB
        Moms mom=momRepository.findById(momid).orElseThrow(()->new ResourceNotFoundException("Mom Not Found"));
        //Create A Task
        Task task=new Task();
        task.setTitle(title);
        task.setAssignedTo(assignedTo);
        //Set Moms Entity
        task.setMom(mom);
        task.setAutoGenerated(false); //manual work ai suggest be block
        task.setApproved(true); //always  approved a manual task
        return taskRepository.save(task);
    }
    //update Task Status
    public Task updatestatus(Long taskid,String status){
        Task task=taskRepository.findById(taskid).orElseThrow(()->new ResourceNotFoundException("Task Not Found"));
        task.setStatus(status);
        return taskRepository.save(task);
    }
    //Get All Tasks
    public List<Task> getalltasks(){
        return taskRepository.findAll();
    }
    //Get The Tasks By Specific User
    public List<TaskResponseDto> gettaskbyuserdto(String email){

        String studentName = userservice.getUserNameByEmail(email);

        return taskRepository.findAll().stream()
                .filter(Task::isApproved)
                .filter(task ->
                        task.getAssignedTo().equalsIgnoreCase(email) ||
                                (studentName != null &&
                                        task.getAssignedTo().equalsIgnoreCase(studentName))
                )
                .map(task -> new TaskResponseDto(
                        task.getId(),
                        task.getTitle(),
                        task.getAssignedTo(),
                        task.getStatus(),
                        task.isAutoGenerated(),
                        task.isApproved(),
                        task.getResources(),
                        task.getMom().getMeeting().getType()
                ))
                .collect(Collectors.toList());
    }
    //Get All The Tasks Based On Task ResponseDto
    public List<TaskResponseDto> getalltaskdto(){
        return taskRepository.findAll()
                .stream()
                .map(task -> new TaskResponseDto(task.getId(),task.getTitle(),task.getAssignedTo(),task.getStatus(),task.isAutoGenerated(),task.isApproved(),task.getResources(),task.getMom().getMeeting().getType()))
                .collect(Collectors.toList());
    }
    //Add Pagination
    public Page<TaskResponseDto> gettaskwithpagination(int page,int size,String sortby,String direction){
        Sort sort=direction.equalsIgnoreCase("desc")
                ?Sort.by(sortby).descending()
                :Sort.by(sortby).ascending();
        Pageable pageable= PageRequest.of(page,size,sort);
        return taskRepository.findAll(pageable).map(task -> new TaskResponseDto(task.getId(),task.getTitle(),task.getAssignedTo(),task.getStatus(),task.isAutoGenerated(),task.isApproved(),task.getResources(),task.getMom().getMeeting().getType()));
    }
    public double calculatemeetingprogress(Long meetingid){
        Moms mom=momRepository.findById(meetingid).orElseThrow(()->new ResourceNotFoundException("Meeting Id Not Found"));
        List<Task> tasks=taskRepository.findByMomId(mom.getId());
        if(tasks.isEmpty()){
            return 0.0;
        }
        long completed=tasks.stream()
                .filter(task -> "DONE".equals(task.getStatus()))
                .count();
        return (completed*100.0)/tasks.size();
    }
    public Task getTaskById(Long taskId) {
        return taskRepository.findById(taskId)
                .orElseThrow(() ->
                        new ResourceNotFoundException("Task not found"));
    }
    // Add these methods to your existing TaskService class
    // Check if a student is assigned a task in a specific meeting
    public boolean isStudentAssignedToMeeting(Long meetingId, String studentEmail) {
        Moms mom = momRepository.findByMeeting_Id(meetingId).orElse(null);
        if (mom == null) {
            return false;
        }

        List<Task> tasks = taskRepository.findByMomId(mom.getId());
        return tasks.stream()
                .anyMatch(task -> studentEmail.equals(task.getAssignedTo()));
    }
    // In com.momentor.mentors.Service.TaskService
    public List<TaskResponseDto> gettaskbymentor(Long mentorId) {
        // Get all meetings for this mentor
        List<Meeting> meetings = meetingRepository.findByMentorid(mentorId);

        // Get all MOMs from these meetings
        List<Long> momIds = meetings.stream()
                .flatMap(m -> momRepository.findByMeeting_Id(m.getId()).stream())
                .map(Moms::getId)
                .collect(Collectors.toList());

        if (momIds.isEmpty()) {
            return new ArrayList<>();
        }

        // Get all tasks from these MOMs
        return taskRepository.findByMomIdIn(momIds).stream()
                .map(task -> new TaskResponseDto(
                        task.getId(),
                        task.getTitle(),
                        task.getAssignedTo(),
                        task.getStatus(),task.isAutoGenerated(),task.isApproved(),task.getResources(),task.getMom().getMeeting().getType()
                ))
                .collect(Collectors.toList());
    }
    public ResponseEntity<?> getMeetingByTaskService(
            Long taskId,
            Authentication authentication
    ) {
        try {
            Task task = getTaskById(taskId);
            if (task == null) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body(new ErrorResponse("Task not found"));
            }

            String email = authentication.getName();
            String role = authentication.getAuthorities().stream()
                    .map(Object::toString)
                    .filter(auth ->
                            auth.contains("ROLE_MENTOR") ||
                                    auth.contains("ROLE_STUDENT") ||
                                    auth.contains("ROLE_ADMIN"))
                    .findFirst()
                    .orElse("");

            // STUDENT can only view their own assigned tasks
            if (role.contains("STUDENT")) {
                String studentName = userservice.getUserNameByEmail(email);
                boolean isAssigned =
                        task.getAssignedTo().equalsIgnoreCase(email) ||
                                (studentName != null &&
                                        task.getAssignedTo().equalsIgnoreCase(studentName));

                if (!isAssigned) {
                    return ResponseEntity.status(HttpStatus.FORBIDDEN)
                            .body(new ErrorResponse("You are not assigned to this task"));
                }
            }

            // MENTOR / ADMIN access
            if (role.contains("MENTOR") || role.contains("ADMIN")) {
                Long userId = userservice.getUserIdByEmail(email);
                Meeting meeting = task.getMom().getMeeting();

                if (!role.contains("ADMIN") &&
                        !meeting.getMentorid().equals(userId)) {

                    return ResponseEntity.status(HttpStatus.FORBIDDEN)
                            .body(new ErrorResponse("You can only view tasks from your own meetings"));
                }
            }
            Meeting meeting = task.getMom().getMeeting();
            Moms mom = momservice.getMomByMeetingOrNull(meeting);
            MeetingWithMomResponseDto dto =
                    new MeetingWithMomResponseDto(
                            meeting.getId(),
                            meeting.getTitle(),
                            meeting.getMeetingdate(),
                            mom != null ? mom.getId() : null,
                            mom != null ? mom.getMomtext() : null
                    );
            return ResponseEntity.ok(dto);
        } catch (ResourceNotFoundException rnfe) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(new ErrorResponse(rnfe.getMessage()));
        } catch (Exception ex) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ErrorResponse("Error fetching meeting: " + ex.getMessage()));
        }
    }
    //Dashboard For Student
    public ResponseEntity<?> getMentorDashboardSummaryService(Authentication authentication) {
        try {
            String email = authentication.getName();
            Long mentorId = userservice.getUserIdByEmail(email);
            List<TaskResponseDto> tasks = gettaskbymentor(mentorId);
            long totalTasks = tasks.size();
            long doneTasks = tasks.stream()
                    .filter(t -> "DONE".equalsIgnoreCase(t.getStatus()))
                    .count();
            long inProgressTasks = tasks.stream()
                    .filter(t -> "IN_PROGRESS".equalsIgnoreCase(t.getStatus()))
                    .count();
            long notStartedTasks = tasks.stream()
                    .filter(t -> "NOT_STARTED".equalsIgnoreCase(t.getStatus()))
                    .count();
            double overallProgress =
                    totalTasks > 0 ? (doneTasks * 100.0) / totalTasks : 0;
            Map<String, Object> response = new HashMap<>();
            response.put("totalTasks", totalTasks);
            response.put("doneTasks", doneTasks);
            response.put("inProgressTasks", inProgressTasks);
            response.put("notStartedTasks", notStartedTasks);
            response.put("overallprogress", overallProgress);
            return ResponseEntity.ok(response);

        } catch (Exception ex) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Failed to load dashboard summary: " + ex.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
        }
    }
    //Dashboard For Mentor
    public ResponseEntity<?> getStudentDashboardSummaryService(Authentication authentication) {
        try {
            String email = authentication.getName();
            List<TaskResponseDto> tasks = gettaskbyuserdto(email);
            long totalTasks = tasks.size();
            long doneTasks = tasks.stream()
                    .filter(t -> "DONE".equalsIgnoreCase(t.getStatus()))
                    .count();
            long inProgressTasks = tasks.stream()
                    .filter(t -> "IN_PROGRESS".equalsIgnoreCase(t.getStatus()))
                    .count();
            long notStartedTasks = tasks.stream()
                    .filter(t -> "NOT_STARTED".equalsIgnoreCase(t.getStatus()))
                    .count();
            double overallProgress =
                    totalTasks > 0 ? (doneTasks * 100.0) / totalTasks : 0;
            Map<String, Object> response = new HashMap<>();
            response.put("totalTasks", totalTasks);
            response.put("doneTasks", doneTasks);
            response.put("inProgressTasks", inProgressTasks);
            response.put("notStartedTasks", notStartedTasks);
            response.put("overallprogress", overallProgress);
            return ResponseEntity.ok(response);

        } catch (Exception ex) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Failed to load dashboard summary: " + ex.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
        }
    }
    //Dashboard for Admin
    public ResponseEntity<?> getAdminDashboardSummaryService() {
        try {
            List<TaskResponseDto> tasks = getalltaskdto();

            long totalTasks = tasks.size();
            long doneTasks = tasks.stream()
                    .filter(t -> "DONE".equalsIgnoreCase(t.getStatus()))
                    .count();
            long inProgressTasks = tasks.stream()
                    .filter(t -> "IN_PROGRESS".equalsIgnoreCase(t.getStatus()))
                    .count();
            long notStartedTasks = tasks.stream()
                    .filter(t -> "NOT_STARTED".equalsIgnoreCase(t.getStatus()))
                    .count();

            double overallProgress =
                    totalTasks > 0 ? (doneTasks * 100.0) / totalTasks : 0;

            Map<String, Object> response = new HashMap<>();
            response.put("totalTasks", totalTasks);
            response.put("doneTasks", doneTasks);
            response.put("inProgressTasks", inProgressTasks);
            response.put("notStartedTasks", notStartedTasks);
            response.put("overallprogress", overallProgress);

            return ResponseEntity.ok(response);

        } catch (Exception ex) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Failed to load dashboard summary: " + ex.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
        }
    }
    // In TaskService.java
    // In TaskService.java - replace existing saveAiTasks implementation with this
    // ...existing code...
    public void saveAiTasks(List<AiTask> tasks, Moms mom, String meetingType, List<Team> teams) {
        // If this is a TEAM meeting, expand AI-assigned team tasks into per-participant drafts
        if ("TEAM".equalsIgnoreCase(meetingType) && teams != null && !teams.isEmpty()) {
            for (AiTask aiTask : tasks) {
                String assigned = aiTask.getAssignedTo() == null ? "" : aiTask.getAssignedTo().trim();

                // Try to match a team (case-insensitive, null-safe)
                Team matchedTeam = teams.stream()
                        .filter(t -> t.getName() != null && !assigned.isEmpty()
                                && t.getName().equalsIgnoreCase(assigned))
                        .findFirst()
                        .orElse(null);

                if (matchedTeam != null && matchedTeam.getParticipants() != null && !matchedTeam.getParticipants().isEmpty()) {
                    // Create one draft task per participant (no team-level task created)
                    for (String participant : matchedTeam.getParticipants()) {
                        Task userTask = new Task();
                        userTask.setTitle(aiTask.getTitle());
                        userTask.setAssignedTo(participant);
                        userTask.setResources(aiTask.getResources());
                        userTask.setAutoGenerated(true);
                        userTask.setApproved(false); // mentor approves individual tasks
                        userTask.setStatus("NOT_STARTED");
                        userTask.setMom(mom);
                        taskRepository.save(userTask);
                    }
                } else {
                    // Fallback: AI assigned to something not matching any team -> save single draft as-is
                    Task draft = new Task();
                    draft.setTitle(aiTask.getTitle());
                    draft.setAssignedTo(assigned);
                    draft.setResources(aiTask.getResources());
                    draft.setAutoGenerated(true);
                    draft.setApproved(false);
                    draft.setStatus("NOT_STARTED");
                    draft.setMom(mom);
                    taskRepository.save(draft);
                }
            }
            return;
        }

        // Handle SOLO (or non-TEAM) meetings: persist each AI task as a draft linked to the MOM
        if (tasks != null && !tasks.isEmpty()) {
            for (AiTask aiTask : tasks) {
                Task draft = new Task();
                draft.setTitle(aiTask.getTitle());
                // For solo meetings AI usually assigns directly to a user (email or name)
                draft.setAssignedTo(aiTask.getAssignedTo() != null ? aiTask.getAssignedTo().trim() : "");
                draft.setResources(aiTask.getResources());
                draft.setAutoGenerated(true);
                draft.setApproved(false); // mentor must approve
                draft.setStatus("NOT_STARTED");
                draft.setMom(mom);
                taskRepository.save(draft);
            }
        }
    }
    // ...existing code...
    //AI Task Deletion
    public void deleteTask(Long taskId) {
        taskRepository.deleteById(taskId);
    }
    private void createtaskforuser(AiTask aiTask, String userName, Moms mom) {
        Task task = new Task();
        task.setTitle(aiTask.getTitle());
        task.setAssignedTo(userName); // Always a user name
        task.setResources(aiTask.getResources());
        task.setAutoGenerated(true);
        task.setApproved(false);
        task.setStatus("NOT_STARTED");
        task.setMom(mom);
        taskRepository.save(task);
    }
    // In TaskService.java
    @Transactional
    public void approveAndExpandAiTask(Long taskId) {
        Task draft = taskRepository.findById(taskId)
                .orElseThrow(() -> new ResourceNotFoundException("Task not found"));

        if (!draft.isAutoGenerated()) {
            throw new RuntimeException("Only AI tasks can be approved here");
        }

        if (draft.isApproved()) {
            return; // already approved/expanded
        }

        // Mark draft as approved (keeps team-level record)
        draft.setApproved(true);
        taskRepository.save(draft);

        String assigned = draft.getAssignedTo();
        Moms mom = draft.getMom();
        Meeting meeting = mom.getMeeting();

        if (meeting != null && "TEAM".equalsIgnoreCase(meeting.getType())) {
            // Find the team by name for this meeting
            // Use a repo method that fetches participants eagerly (see repository suggestion)
            List<Team> teams = teamRepository.findByMeetingIdWithParticipants(meeting.getId());
            Team team = teams.stream()
                    .filter(t -> t.getName().equalsIgnoreCase(assigned.trim()))
                    .findFirst()
                    .orElse(null);

            if (team != null && team.getParticipants() != null) {
                for (String participant : team.getParticipants()) {
                    createApprovedUserTaskFromDraft(draft, participant, mom);
                }
                return;
            }
        }

        // Fallback: if not a team or no team found, try to resolve to a user (by email or name)
        String userEmail = userservice.getUserNameByEmail(assigned); // implement helper in userservice
        if (userEmail != null) {
            createApprovedUserTaskFromDraft(draft, userEmail, mom);
        }
    }
    private void createApprovedUserTaskFromDraft(Task draft, String userNameOrEmail, Moms mom) {
        Task task = new Task();
        task.setTitle(draft.getTitle());
        task.setAssignedTo(userNameOrEmail);
        task.setResources(draft.getResources());
        task.setAutoGenerated(true);
        task.setApproved(true); // already approved by mentor
        task.setStatus("NOT_STARTED");
        task.setMom(mom);
        taskRepository.save(task);
    }

    @Transactional //Summary Field For Student
    public List<SimpleMeetingSummaryDto> getMeetingSummaryForStudent(String username) {
        // Get student's actual email/name
        String studentEmail = userservice.getUserEmailByName(username);
        if (studentEmail == null) {
            studentEmail = username;
        }

        Set<Long> meetingIds = new HashSet<>();
        Map<Long, Meeting> meetingMap = new HashMap<>();

        final String finalStudentEmail = studentEmail;

        // 1. Find all meetings where student has assigned tasks
        List<Task> tasks = taskRepository.findAll().stream()
                .filter(t -> {
                    String assignedTo = t.getAssignedTo();
                    if (assignedTo == null) return false;
                    return assignedTo.equalsIgnoreCase(finalStudentEmail) ||
                            assignedTo.equalsIgnoreCase(username);
                })
                .collect(Collectors.toList());

        for (Task task : tasks) {
            if (task.getMom() != null && task.getMom().getMeeting() != null) {
                Long meetingId = task.getMom().getMeeting().getId();
                meetingIds.add(meetingId);
                meetingMap.put(meetingId, task.getMom().getMeeting());
            }
        }

        // 2. Find all TEAM meetings where student is a participant in a team
        List<Meeting> allMeetings = meetingRepository.findAll();
        for (Meeting meeting : allMeetings) {
            if (meeting.getType() != null && "TEAM".equalsIgnoreCase(meeting.getType())) {
                if (meeting.getTeams() != null) {
                    for (Team team : meeting.getTeams()) {
                        if (team.getParticipants() != null &&
                                (team.getParticipants().contains(finalStudentEmail) ||
                                        team.getParticipants().contains(username))) {
                            Long meetingId = meeting.getId();
                            meetingIds.add(meetingId);
                            meetingMap.put(meetingId, meeting);
                            break;
                        }
                    }
                }
            }
        }

        // Convert to SimpleMeetingSummaryDto
        return meetingMap.values().stream().map(meeting -> {
            // Get MOM
            Moms mom = momRepository.findByMeeting_Id(meeting.getId()).orElse(null);
            String momText = mom != null ? mom.getMomtext() : "No minutes recorded";

            // Get Audio files - safe access
            List<AudioFileDto> audioFiles = (meeting.getMeetingAudios() != null && !meeting.getMeetingAudios().isEmpty()) ?
                    meeting.getMeetingAudios().stream()
                            .map(audio -> new AudioFileDto(
                                    audio.getId(),
                                    audio.getFileName(),
                                    audio.getFilePath(),
                                    audio.getUploadedAt()
                            ))
                            .collect(Collectors.toList())
                    : new ArrayList<>();

            // Get Teams with participants - safe access
            List<TeamDto> teamDetails = (meeting.getTeams() != null && !meeting.getTeams().isEmpty()) ?
                    meeting.getTeams().stream()
                            .map(team -> new TeamDto(
                                    team.getName(),
                                    team.getParticipants() != null ? new ArrayList<>(team.getParticipants()) : new ArrayList<>()
                            ))
                            .collect(Collectors.toList())
                    : new ArrayList<>();

            return new SimpleMeetingSummaryDto(
                    meeting.getId(),
                    meeting.getTitle(),
                    meeting.getMeetingdate(),
                    meeting.getType(),
                    momText,
                    audioFiles,
                    teamDetails
            );
        }).collect(Collectors.toList());
    }
    @Transactional //Summary Field For Mentor
    public List<SimpleMeetingSummaryDto> getMeetingSummaryForMentor(Long mentorId) {
        List<Meeting> meetings = meetingRepository.findByMentorIdWithDetails(mentorId);

        return meetings.stream().map(meeting -> {
            // Get MOM
            Moms mom = momRepository.findByMeeting_Id(meeting.getId()).orElse(null);
            String momText = mom != null ? mom.getMomtext() : "No minutes recorded";

            // Get Audio files - now safe to access
            List<AudioFileDto> audioFiles = (meeting.getMeetingAudios() != null && !meeting.getMeetingAudios().isEmpty()) ?
                    meeting.getMeetingAudios().stream()
                            .map(audio -> new AudioFileDto(
                                    audio.getId(),
                                    audio.getFileName(),
                                    audio.getFilePath(),
                                    audio.getUploadedAt()
                            ))
                            .collect(Collectors.toList())
                    : new ArrayList<>();

            // Get Teams with participants - now safe to access
            List<TeamDto> teamDetails = (meeting.getTeams() != null && !meeting.getTeams().isEmpty()) ?
                    meeting.getTeams().stream()
                            .map(team -> new TeamDto(
                                    team.getName(),
                                    team.getParticipants() != null ? new ArrayList<>(team.getParticipants()) : new ArrayList<>()
                            ))
                            .collect(Collectors.toList())
                    : new ArrayList<>();

            return new SimpleMeetingSummaryDto(
                    meeting.getId(),
                    meeting.getTitle(),
                    meeting.getMeetingdate(),
                    meeting.getType(),
                    momText,
                    audioFiles,
                    teamDetails
            );
        }).collect(Collectors.toList());
    }
}